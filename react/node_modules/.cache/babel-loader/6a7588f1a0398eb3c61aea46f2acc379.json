{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTransformPropertyName = getTransformPropertyName;\nexports.clamp = clamp;\nexports.bezierProgress = bezierProgress;\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar storedTransformPropertyName_ = void 0; // Returns the name of the correct transform property to use on the current browser.\n\nfunction getTransformPropertyName(globalObj) {\n  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (storedTransformPropertyName_ === undefined || forceRefresh) {\n    var el = globalObj.document.createElement('div');\n    var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';\n    storedTransformPropertyName_ = transformPropertyName;\n  }\n\n  return storedTransformPropertyName_;\n} // Clamps a value between the minimum and the maximum, returning the clamped value.\n\n\nfunction clamp(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return Math.min(max, Math.max(min, value));\n} // Returns the easing value to apply at time t, for a given cubic bezier curve.\n// Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.\n// Paramters are as follows:\n// - time: The current time in the animation, scaled between 0 and 1.\n// - x1: The x value of control point P1.\n// - y1: The y value of control point P1.\n// - x2: The x value of control point P2.\n// - y2: The y value of control point P2.\n\n\nfunction bezierProgress(time, x1, y1, x2, y2) {\n  return getBezierCoordinate_(solvePositionFromXValue_(time, x1, x2), y1, y2);\n} // Compute a single coordinate at a position point between 0 and 1.\n// c1 and c2 are the matching coordinate on control points P1 and P2, respectively.\n// Control points P0 and P3 are assumed to be (0,0) and (1,1), respectively.\n// Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.\n\n\nfunction getBezierCoordinate_(t, c1, c2) {\n  // Special case start and end.\n  if (t === 0 || t === 1) {\n    return t;\n  } // Step one - from 4 points to 3\n\n\n  var ic0 = t * c1;\n  var ic1 = c1 + t * (c2 - c1);\n  var ic2 = c2 + t * (1 - c2); // Step two - from 3 points to 2\n\n  ic0 += t * (ic1 - ic0);\n  ic1 += t * (ic2 - ic1); // Final step - last point\n\n  return ic0 + t * (ic1 - ic0);\n} // Project a point onto the Bezier curve, from a given X. Calculates the position t along the curve.\n// Adapted from https://github.com/google/closure-library/blob/master/closure/goog/math/bezier.js.\n\n\nfunction solvePositionFromXValue_(xVal, x1, x2) {\n  var EPSILON = 1e-6;\n  var MAX_ITERATIONS = 8;\n\n  if (xVal <= 0) {\n    return 0;\n  } else if (xVal >= 1) {\n    return 1;\n  } // Initial estimate of t using linear interpolation.\n\n\n  var t = xVal; // Try gradient descent to solve for t. If it works, it is very fast.\n\n  var tMin = 0;\n  var tMax = 1;\n  var value = 0;\n\n  for (var i = 0; i < MAX_ITERATIONS; i++) {\n    value = getBezierCoordinate_(t, x1, x2);\n    var derivative = (getBezierCoordinate_(t + EPSILON, x1, x2) - value) / EPSILON;\n\n    if (Math.abs(value - xVal) < EPSILON) {\n      return t;\n    } else if (Math.abs(derivative) < EPSILON) {\n      break;\n    } else {\n      if (value < xVal) {\n        tMin = t;\n      } else {\n        tMax = t;\n      }\n\n      t -= (value - xVal) / derivative;\n    }\n  } // If the gradient descent got stuck in a local minimum, e.g. because\n  // the derivative was close to 0, use a Dichotomy refinement instead.\n  // We limit the number of interations to 8.\n\n\n  for (var _i = 0; Math.abs(value - xVal) > EPSILON && _i < MAX_ITERATIONS; _i++) {\n    if (value < xVal) {\n      tMin = t;\n      t = (t + tMax) / 2;\n    } else {\n      tMax = t;\n      t = (t + tMin) / 2;\n    }\n\n    value = getBezierCoordinate_(t, x1, x2);\n  }\n\n  return t;\n}","map":null,"metadata":{},"sourceType":"script"}